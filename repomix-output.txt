This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-21T06:08:19.244Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
data/
  sources/
    adjectives.json
  wordsInSupabase.json
src/
  controllers/
    adjectives/
      checkingSupabase.ts
      checkingWiktionary.ts
      fetchingInflections.ts
      fetchingIPA.ts
      fetchingSyllabifications.ts
      fetchingTranslations.ts
      fetchingTranslationsEnglish.ts
      fetchingTranslationsFrench.ts
      fetchingTranslationsGerman.ts
      fetchingTranslationsItalian.ts
      handlingAdjective.ts
      uploadingToSupabase.ts
  types/
    global.d.ts
  utils/
    adjustingCSV.ts
    askToContinue.ts
    checkingAgainstCSV.ts
    checkingAgainstDatabase.ts
    checkingJSONFiles.ts
    creatingLocalBackup.ts
    deletingFromCSV.ts
    deletingFromJSONFiles.ts
    downloadingSupabaseData.ts
    readingCSV.ts
    readingLocalJSON.ts
    readingSourceFile.ts
    syncLocalWithSupabase.ts
    writingToCSV.ts
  server.ts
.dockerignore
.prettierrc
docker-compose.yml
Dockerfile
eslint.config.js
package.json
tsconfig.json

================================================================
Files
================================================================

================
File: data/sources/adjectives.json
================
[
  "rojo",
  "grande",
  "armadillo"
]

================
File: data/wordsInSupabase.json
================
[
  {
    "singular_masculine": "abandonado",
    "singular_feminine": "abandonada",
    "plural_masculine": "abandonados",
    "plural_feminine": "abandonadas",
    "ipa_singular_masculine": "a.Œ≤ÃûanÃ™.dÃ™oÀàna.√∞Ãûo",
    "ipa_singular_feminine": "a.Œ≤an.√∞oÀàna.√∞a",
    "ipa_plural_masculine": "a.Œ≤an.√∞oÀàna.√∞os",
    "ipa_plural_feminine": "a.Œ≤an.√∞oÀàna.√∞as",
    "syllabification_singular_masculine": "a-ban-do-na-do",
    "syllable_count_singular_masculine": 5,
    "syllabification_singular_feminine": "a-ban-do-na-da",
    "syllable_count_singular_feminine": 5,
    "syllabification_plural_masculine": "a-ban-do-na-dos",
    "syllable_count_plural_masculine": 5,
    "syllabification_plural_feminine": "a-ban-do-na-das",
    "syllable_count_plural_feminine": 5,
    "links_to_audio_files_singular_masculine": [],
    "links_to_audio_files_singular_feminine": [],
    "links_to_audio_files_plural_masculine": [],
    "links_to_audio_files_plural_feminine": [],
    "english_translations": [
      "abandoned",
      "forsaken",
      "neglected",
      "deserted"
    ],
    "french_translations": [
      "abandonn√©"
    ],
    "italian_translations": [
      "abbandonato"
    ],
    "german_translations": [
      "verlassen",
      "einsam",
      "schlampig",
      "nachl√§ssig",
      "herrenlos",
      "verwahrlost"
    ]
  },
  {
    "singular_masculine": "abierto",
    "singular_feminine": "abierta",
    "plural_masculine": "abiertos",
    "plural_feminine": "abiertas",
    "ipa_singular_masculine": "aÀàŒ≤Ãûje…æ.tÃ™o",
    "ipa_singular_feminine": "aÀàŒ≤Ãûje…æ.tÃ™a",
    "ipa_plural_masculine": "aÀàŒ≤Ãûje…æ.tÃ™os",
    "ipa_plural_feminine": "aŒ≤je…æ.tas",
    "syllabification_singular_masculine": "a-bier-to",
    "syllable_count_singular_masculine": 3,
    "syllabification_singular_feminine": "a-bier-ta",
    "syllable_count_singular_feminine": 3,
    "syllabification_plural_masculine": "a-bier-tos",
    "syllable_count_plural_masculine": 3,
    "syllabification_plural_feminine": "a-bier-tas",
    "syllable_count_plural_feminine": 3,
    "links_to_audio_files_singular_masculine": [],
    "links_to_audio_files_singular_feminine": [],
    "links_to_audio_files_plural_masculine": [],
    "links_to_audio_files_plural_feminine": [],
    "english_translations": [
      "open",
      "overt"
    ],
    "french_translations": [
      "ouvert"
    ],
    "italian_translations": [
      "aperto"
    ],
    "german_translations": [
      "ge√∂ffnet",
      "offen",
      "offenherzig"
    ]
  }
]

================
File: src/controllers/adjectives/checkingSupabase.ts
================
import "dotenv/config";
import chalk from "chalk";
import {createClient} from "@supabase/supabase-js";

const SUPABASE_URL = process.env.SUPABASE_URL!;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

export async function checkingSupabase(adjective: Adjective) {
  console.log(`${chalk.white("\nüí° checking supabase")}`);

  try {
    const {data, error} = await supabase
      .from("spanish_adjectives")
      .select("id")
      .eq("singular_masculine", adjective.singular_masculine);

    if (data && data.length > 0) {
      return true;
    } else {
      console.log(
        `‚úÖ ${chalk.green(adjective.singular_masculine, "does not exist on supabase, proceeding...")}`,
      );
      return false;
    }
  } catch (error) {
    console.log(
      `${chalk.red("Unexpected error:", (error as Error).message)}\n`,
    );
  }
}

================
File: src/controllers/adjectives/checkingWiktionary.ts
================
import axios from "axios";
import chalk from "chalk";

export async function checkingWiktionary(adjective: Adjective) {
  console.log("üí° checking wiktionary...");

  const url = `https://es.m.wiktionary.org/wiki/${encodeURIComponent(
    adjective.singular_masculine,
  )}`;

  try {
    const response = await axios.get(url);
    if (response.status === 200) {
      console.log(
        `${chalk.green("‚úÖ ", adjective.singular_masculine, " found in wiktionary")}`,
      );
      return true;
    }
  } catch (error) {
    console.log(
      `${chalk.red("Unexpected error:", (error as Error).message)}\n`,
    );
  }
  return false;
}

================
File: src/controllers/adjectives/fetchingInflections.ts
================
import axios from "axios";
import * as cheerio from "cheerio";
import chalk from "chalk";

export async function fetchingInflections(adjective: Adjective) {
  console.log("üí° fetching inflections...");

  const url = `https://es.m.wiktionary.org/wiki/${encodeURIComponent(
    adjective.singular_masculine,
  )}`;

  try {
    const response = await axios.get(url);
    const $ = cheerio.load(response.data);

    const inflectionTable = $(".inflection-table");

    if (inflectionTable.length > 0) {
      adjective.plural_masculine = inflectionTable
        .find("tr:nth-child(2) td:nth-child(3)")
        .text()
        .trim();
      adjective.singular_feminine = inflectionTable
        .find("tr:nth-child(3) td:nth-child(2)")
        .text()
        .trim();
      adjective.plural_feminine = inflectionTable
        .find("tr:nth-child(3) td:nth-child(3)")
        .text()
        .trim();
      console.log(`${chalk.green("‚úÖ inflections found")}`);
      return true;
    } else {
      return false;
    }
  } catch (error) {
    console.log(
      `${chalk.red("Unexpected error:", (error as Error).message)}\n`,
    );
    return;
  }
}

================
File: src/controllers/adjectives/fetchingIPA.ts
================
import chalk from "chalk";
import axios from "axios";
import * as cheerio from "cheerio";

export async function fetchingIPA(adjective: Adjective): Promise<boolean> {
  console.log(`üí° Fetching IPA for: ${adjective.singular_masculine}`);

  try {
    const inflections: AdjectiveInflectionsUnion[] = [
      "singular_masculine",
      "plural_masculine",
      "singular_feminine",
      "plural_feminine",
    ];

    for (const inflection of inflections) {
      const inflectionValue = adjective[inflection];

      const url = `https://es.m.wiktionary.org/wiki/${encodeURIComponent(inflectionValue)}`;

      const response = await axios.get(url);
      const $ = cheerio.load(response.data);

      const dataTable = $(".pron-graf");

      if (dataTable.length > 0) {
        let ipa = dataTable
          .find("tr:nth-child(2) td:nth-child(2)")
          .text()
          .trim();
        ipa = ipa.replace(/].*$/, "]").trim();
        ipa = ipa.replace(/[\[\]]/g, "").trim();

        const ipaKey = `ipa_${inflection}` as AdjectiveIPAUnion;
        adjective[ipaKey] = ipa;

        console.log(`${chalk.green("‚úÖ IPA found for:", inflection)}`, ipa);
      } else {
        console.log(`${chalk.red("‚ùå No IPA found for:", inflectionValue)}`);
        return false;
      }
    }

    return true;
  } catch (error) {
    console.log(
      `${chalk.red("Unexpected error while fetching IPA:", (error as Error).message)}`,
    );
    return false;
  }
}

================
File: src/controllers/adjectives/fetchingSyllabifications.ts
================
import axios from "axios";
import * as cheerio from "cheerio";
import chalk from "chalk";

import {writingToCSV} from "../../utils/writingToCSV";
import {deletingFromCSV} from "../../utils/deletingFromCSV";

export async function fetchingSyllabifications(
  word: Word,
  sourceFilePath: FilePath,
) {
  console.log("üí° fetching syllabifications");

  try {
    const inflections: string[] = [
      "singular_masculine",
      "plural_masculine",
      "singular_feminine",
      "plural_feminine",
    ];

    for (const inflection of inflections) {
      const url = `https://es.m.wiktionary.org/wiki/${encodeURIComponent(
        word[inflection],
      )}`;

      const response = await axios.get(url);
      const $ = cheerio.load(response.data);

      const dataTable = $(".pron-graf");

      if (dataTable.length > 0) {
        let syllabification = dataTable
          .find("tr:contains('silabaci√≥n') td:nth-child(2)")
          .text()
          .trim();

        syllabification = syllabification.replace(/\[\d+\]/g, "").trim();

        if (syllabification) {
          word[`syllabification_${inflection}`] = syllabification;
          word[`syllable_count_${inflection}`] =
            syllabification.split("-").length;
        }
      } else {
        console.log(
          `${chalk.red("‚ùå no syllabification found for ", inflection)}`,
        );
        await writingToCSV(
          word.singular_masculine,
          "./data/processed/withError/syllabifications.csv",
        );
        await deletingFromCSV(word.singular_masculine, sourceFilePath);
        return;
      }
    }
    console.log(`${chalk.green("‚úÖ syllabifications found")}`);
  } catch (error) {
    console.log(
      `${chalk.red("Unexpected error:", (error as Error).message)}\n`,
    );
    await writingToCSV(
      word.singular_masculine,
      "./data/processed/withError/syllabifications.csv",
    );
    await deletingFromCSV(word.singular_masculine, sourceFilePath);
    return;
  }
}

================
File: src/controllers/adjectives/fetchingTranslations.ts
================
import chalk from "chalk";

import {writingToCSV} from "../utils/writingToCSV";
import {deletingFromCSV} from "../utils/deletingFromCSV";

import {fetchingTranslationsEnglish} from "./fetchingTranslationsEnglish";
import {fetchingTranslationsGerman} from "./fetchingTranslationsGerman";
import {fetchingTranslationsItalian} from "./fetchingTranslationsItalian";
import {fetchingTranslationsFrench} from "./fetchingTranslationsFrench";

export async function fetchingTranslations(word, sourceFilePath) {
  console.log("üí° fetching translations:");

  try {
    await fetchingTranslationsEnglish(word, sourceFilePath);
    await fetchingTranslationsGerman(word, sourceFilePath);
    await fetchingTranslationsItalian(word, sourceFilePath);
    await fetchingTranslationsFrench(word, sourceFilePath);
  } catch (error) {
    console.log(`${chalk.red("Unexpected error:", error.message)}\n`);
    await writingToCSV(
      word.singular_masculine,
      "./data/processed/withError/translations.csv",
    );
    await deletingFromCSV(word.singular_masculine, sourceFilePath);
    return;
  }
}

================
File: src/controllers/adjectives/fetchingTranslationsEnglish.ts
================
import axios from "axios";
import * as cheerio from "cheerio";
import chalk from "chalk";

import {writingToCSV} from "../utils/writingToCSV";
import {deletingFromCSV} from "../utils/deletingFromCSV";

export async function fetchingTranslationsEnglish(word, sourceFilePath) {
  console.log("üí° english");

  try {
    const url = `https://enes.dict.cc/?s=${word.singular_masculine}`;
    const response = await axios.get(url);
    const $ = cheerio.load(response.data);

    const scriptContent = $('script:contains("var nres=")').text();

    const spanishWords = scriptContent.match(
      /var c1Arr = new Array\((.*?)\);/,
    )[1];
    const englishWords = scriptContent.match(
      /var c2Arr = new Array\((.*?)\);/,
    )[1];

    const regex = /"(.*?)"/g;

    const spanishWordsArray = spanishWords
      .match(regex)
      .map((match) => match.slice(1, -1))
      .slice(1);
    const englishWordsArray = englishWords
      .match(regex)
      .map((match) => match.slice(1, -1))
      .slice(1);

    spanishWordsArray.forEach((spanishWord, index) => {
      if (spanishWord === word.singular_masculine) {
        word.english_translations.push(englishWordsArray[index]);
      }
    });

    console.log(`${chalk.green("‚úÖ english translations found")}`);
  } catch (error) {
    console.log(`${chalk.red("Unexpected error:", error.message)}\n`);
    await writingToCSV(
      word.singular_masculine,
      "./data/processed/withError/translationsEN.csv",
    );
    await deletingFromCSV(word.singular_masculine, sourceFilePath);
    return;
  }
}

================
File: src/controllers/adjectives/fetchingTranslationsFrench.ts
================
import axios from "axios";
import * as cheerio from "cheerio";
import chalk from "chalk";

import {writingToCSV} from "../utils/writingToCSV";
import {deletingFromCSV} from "../utils/deletingFromCSV";

export async function fetchingTranslationsFrench(word, sourceFilePath) {
  console.log("üí° french");

  try {
    const url = `https://www.wordreference.com/esfr/${word.singular_masculine}`;
    const response = await axios.get(url);
    const $ = cheerio.load(response.data);

    const translation = $(".ToWrd").eq(1).text().trim();
    word.french_translations.push(translation.replace(/\badj\b/g, "").trim());

    console.log(`${chalk.green("‚úÖ french translations found")}`);
  } catch (error) {
    console.log(`${chalk.red("Unexpected error:", error.message)}\n`);
    await writingToCSV(
      word.singular_masculine,
      "./data/processed/withError/translationsFR.csv",
    );
    await deletingFromCSV(word.singular_masculine, sourceFilePath);
    return;
  }
}

================
File: src/controllers/adjectives/fetchingTranslationsGerman.ts
================
import axios from "axios";
import * as cheerio from "cheerio";
import chalk from "chalk";

import {writingToCSV} from "../utils/writingToCSV";
import {deletingFromCSV} from "../utils/deletingFromCSV";

export async function fetchingTranslationsGerman(word, sourceFilePath) {
  console.log("üí° german");

  try {
    const url = `https://dees.dict.cc/?s=${word.singular_masculine}`;
    const response = await axios.get(url);
    const $ = cheerio.load(response.data);

    const scriptContent = $('script:contains("var nres=")').text();

    const spanishWords = scriptContent.match(
      /var c1Arr = new Array\((.*?)\);/,
    )[1];
    const germanWords = scriptContent.match(
      /var c2Arr = new Array\((.*?)\);/,
    )[1];

    const regex = /"(.*?)"/g;
    const spanishWordsArray = spanishWords
      .match(regex)
      .map((match) => match.slice(1, -1))
      .slice(1);
    const germanWordsArray = germanWords
      .match(regex)
      .map((match) => match.slice(1, -1))
      .slice(1);

    spanishWordsArray.forEach((spanishWord, index) => {
      if (spanishWord === word.singular_masculine) {
        word.german_translations.push(germanWordsArray[index]);
      }
    });

    console.log(`${chalk.green("‚úÖ german translations found")}`);
  } catch (error) {
    console.log(`${chalk.red("Unexpected error:", error.message)}\n`);
    await writingToCSV(
      word.singular_masculine,
      "./data/processed/withError/translationsDE.csv",
    );
    await deletingFromCSV(word.singular_masculine, sourceFilePath);
    return;
  }
}

================
File: src/controllers/adjectives/fetchingTranslationsItalian.ts
================
import axios from "axios";
import * as cheerio from "cheerio";
import chalk from "chalk";

import {writingToCSV} from "../utils/writingToCSV";
import {deletingFromCSV} from "../utils/deletingFromCSV";

export async function fetchingTranslationsItalian(word, sourceFilePath) {
  console.log("üí° italian");

  try {
    const url = `https://www.wordreference.com/esit/${word.singular_masculine}`;
    const response = await axios.get(url);
    const $ = cheerio.load(response.data);

    let translation = $(".tran").first().text().trim();
    word.italian_translations.push(translation.replace(/\(.*?\)/g, "").trim());

    console.log(`${chalk.green("‚úÖ italian translations found")}`);
  } catch (error) {
    console.log(`${chalk.red("Unexpected error:", error.message)}\n`);
    await writingToCSV(
      word.singular_masculine,
      "./data/processed/withError/translationsIT.csv",
    );
    await deletingFromCSV(word.singular_masculine, sourceFilePath);
    return;
  }
}

================
File: src/controllers/adjectives/handlingAdjective.ts
================
import chalk from "chalk";

import {checkingAgainstDatabase} from "../../utils/checkingAgainstDatabase";
import {checkingWiktionary} from "./checkingWiktionary";
import {fetchingInflections} from "./fetchingInflections";
import {fetchingIPA} from "./fetchingIPA";
import {fetchingSyllabifications} from "./fetchingSyllabifications";
import {fetchingTranslations} from "./fetchingTranslations";
import {uploadingToSupabase} from "./uploadingToSupabase";

export async function handlingAdjective(word: Word) {
  try {
    console.log(`${chalk.white("\nüí° processing adjective: ", word)}`);

    const adjective: Adjective = {
      singular_masculine: "",
      singular_feminine: "",
      plural_masculine: "",
      plural_feminine: "",
      ipa_singular_masculine: "",
      ipa_singular_feminine: "",
      ipa_plural_masculine: "",
      ipa_plural_feminine: "",
      syllabification_singular_masculine: "",
      syllable_count_singular_masculine: "",
      syllabification_singular_feminine: "",
      syllable_count_singular_feminine: "",
      syllabification_plural_masculine: "",
      syllable_count_plural_masculine: "",
      syllabification_plural_feminine: "",
      syllable_count_plural_feminine: "",
      links_to_audio_files_singular_masculine: [],
      links_to_audio_files_singular_feminine: [],
      links_to_audio_files_plural_masculine: [],
      links_to_audio_files_plural_feminine: [],
      english_translations: [],
      french_translations: [],
      italian_translations: [],
      german_translations: [],
    };

    // setting the adjective
    adjective.singular_masculine = word;

    // checking against adjective database
    const existsInDatabase = await checkingAgainstDatabase(adjective);
    if (existsInDatabase) {
      console.log(
        `${chalk.yellow("‚ö†Ô∏è ", adjective.singular_masculine, " already exists in database\n‚ö†Ô∏è proceeding to next word\n")}`,
      );
      return;
    } else {
      return false;
    }
    // todo: add else to save to adjectives not in db.json

    // checking if word is on wiktionary
    const isInWiktionary = await checkingWiktionary(adjective);
    if (!isInWiktionary) {
      console.log(
        `${chalk.red("‚ùå ", adjective.singular_masculine, " not found in wiktionary, exiting...\n")}`,
      );
      return;
    } else {
      return false;
    }
    // todo: add else to save to adjectives not in wiktionary.json

    // fetching inflections of word from wiktionary
    const inflectionsFound = await fetchingInflections(adjective);
    if (!inflectionsFound) {
      console.log(
        `${chalk.red("‚ùå no inflections found for ", adjective.singular_masculine, ", exiting...\n")}`,
      );
      return;
    } else {
      return false;
    }
    // todo: add else to save to adjectives missing inflections .json

    // fetching IPA of word from wiktionary
    const foundIPA = await fetchingIPA(adjective);
    if (!foundIPA) {
      console.log(`${chalk.red("‚ùå couldnt find all IPAs, exiting...\n")}`);
      return;
    } else {
      return false;
    }
    // todo: add else to save to adjectives missing IPA .json

    // todo: add missing functions: syllabifications, translations, see bottom comment

    console.log(`${chalk.red("\nüí° done and gone")}`);
  } catch (error) {
    console.log(
      `${chalk.red("Unexpected error:", (error as Error).message)}\n`,
    );
  }
}

/*
        // fetching IPA of word from wiktionary
        await fetchingIPA(adjective, sourceFilePath)
        // await askToContinue()
    
        // fetching syllabifications from wiktionary
        await fetchingSyllabifications(adjective, sourceFilePath)
        // await askToContinue()
    
        // fetching translations
        await fetchingTranslations(adjective, sourceFilePath)
        // await askToContinue()
    
        // uploading to supabase
        await uploadingToSupabase(adjective)
    
        */

================
File: src/controllers/adjectives/uploadingToSupabase.ts
================
import "dotenv/config";
import {createClient} from "@supabase/supabase-js";
import chalk from "chalk";

const SUPABASE_URL = process.env.SUPABASE_URL!;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

export async function uploadingToSupabase(adjective: Adjective) {
  try {
    const wordData = {
      singular_masculine: adjective.singular_masculine,
      singular_feminine: adjective.singular_feminine,
      plural_masculine: adjective.plural_masculine,
      plural_feminine: adjective.plural_feminine,
      ipa_singular_masculine: adjective.ipa_singular_masculine,
      ipa_singular_feminine: adjective.ipa_singular_feminine,
      ipa_plural_masculine: adjective.ipa_plural_masculine,
      ipa_plural_feminine: adjective.ipa_plural_feminine,
      syllabification_singular_masculine:
        adjective.syllabification_singular_masculine,
      syllable_count_singular_masculine:
        adjective.syllable_count_singular_masculine,
      syllabification_singular_feminine:
        adjective.syllabification_singular_feminine,
      syllable_count_singular_feminine:
        adjective.syllable_count_singular_feminine,
      syllabification_plural_masculine:
        adjective.syllabification_plural_masculine,
      syllable_count_plural_masculine:
        adjective.syllable_count_plural_masculine,
      syllabification_plural_feminine:
        adjective.syllabification_plural_feminine,
      syllable_count_plural_feminine: adjective.syllable_count_plural_feminine,
      links_to_audio_files_singular_masculine: [],
      links_to_audio_files_singular_feminine: [],
      links_to_audio_files_plural_masculine: [],
      links_to_audio_files_plural_feminine: [],
      english_translations: adjective.english_translations,
      french_translations: adjective.french_translations,
      italian_translations: adjective.italian_translations,
      german_translations: adjective.german_translations,
    };

    const {data, error} = await supabase
      .from("spanish_adjectives")
      .insert(wordData);

    if (error) {
      throw new Error(`Error inserting word: ${error.message}`);
    }

    console.log(`${chalk.green("‚úÖ uploaded successfully to supabase")}`);
  } catch (error) {
    console.log(
      `${chalk.red("Unexpected error:", (error as Error).message)}\n`,
    );
  }
}

================
File: src/types/global.d.ts
================
declare global {
  type ProcessedWords = string[];

  type ProcessedWordsCount = number;

  type FilePath = string;

  type FilePaths = FilePath[];

  type Word = string;

  type Words = Word[];

  interface Adjective {
    singular_masculine: string;
    singular_feminine: string;
    plural_masculine: string;
    plural_feminine: string;
    ipa_singular_masculine: string;
    ipa_singular_feminine: string;
    ipa_plural_masculine: string;
    ipa_plural_feminine: string;
    syllabification_singular_masculine: string;
    syllable_count_singular_masculine: string;
    syllabification_singular_feminine: string;
    syllable_count_singular_feminine: string;
    syllabification_plural_masculine: string;
    syllable_count_plural_masculine: string;
    syllabification_plural_feminine: string;
    syllable_count_plural_feminine: string;
    links_to_audio_files_singular_masculine: string[];
    links_to_audio_files_singular_feminine: string[];
    links_to_audio_files_plural_masculine: string[];
    links_to_audio_files_plural_feminine: string[];
    english_translations: string[];
    french_translations: string[];
    italian_translations: string[];
    german_translations: string[];
  }

  type Adjectives = Adjective[];

  // Union type for inflections
  type AdjectiveInflectionsUnion = keyof Pick<
    Adjective,
    | "singular_masculine"
    | "singular_feminine"
    | "plural_masculine"
    | "plural_feminine"
  >;

  // Union type for IPA properties
  type AdjectiveIPAUnion = keyof Pick<
    Adjective,
    | "ipa_singular_masculine"
    | "ipa_singular_feminine"
    | "ipa_plural_masculine"
    | "ipa_plural_feminine"
  >;
}

export {};

================
File: src/utils/adjustingCSV.ts
================
import fs from "fs/promises";
import Papa from "papaparse";

async function transformCSV() {
  const sourceFilePath = "./data/backups/adjectives_backup.csv";
  const targetFilePath = "./data/sources/adjectives_backup_transformed.csv";

  try {
    const sourceData = await fs.readFile(sourceFilePath, "utf8");

    const parsedData = Papa.parse(sourceData, {
      header: true,
      skipEmptyLines: true,
    });

    const transformedData = parsedData.data.map((row) => ({
      word: row.word,
    }));

    const updatedCSV = Papa.unparse(transformedData, {
      header: true,
    });

    await fs.writeFile(targetFilePath, updatedCSV, "utf8");

    console.log("‚úÖ Transformation complete!");
    console.log("Output written to:", targetFilePath);
  } catch (error) {
    console.log("‚ùå Error:", error.message);
  }
}

transformCSV();

================
File: src/utils/askToContinue.ts
================
import readline from "readline";

export async function askToContinue() {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    rl.question(
      "Do you want to continue with the next step? (Y/n) \n",
      (answer) => {
        rl.close();
        resolve(answer.trim().toLowerCase() === "y" || answer.trim() === "");
      },
    );
  });
}

================
File: src/utils/checkingAgainstCSV.ts
================
import fs from "fs/promises";
import Papa from "papaparse";
import chalk from "chalk";

import {deletingFromCSV} from "./deletingFromCSV";

export async function checkingAgainstCSV(word, sourceFilePath) {
  const csvFilePaths = [
    "./data/processed/wordsInSupabase.csv",
    "./data/processed/withError/inflections.csv",
    "./data/processed/withError/ipa.csv",
    "./data/processed/withError/syllabifications.csv",

    "./data/processed/withError/translationsDE.csv",
    "./data/processed/withError/translationsEN.csv",
    "./data/processed/withError/translationsFR.csv",
    "./data/processed/withError/translationsIT.csv",

    "./data/processed/withError/wiktionary.csv",
  ];

  console.log("üí° checking csv files");

  try {
    for (const filePath of csvFilePaths) {
      console.log(`üí° checking ${filePath}`);
      const csvData = await fs.readFile(filePath, "utf8");
      const parsedCSVData = Papa.parse(csvData, {
        header: false,
        skipEmptyLines: true,
      }).data;
      const wordExistsInCSV = parsedCSVData.some((row) => row[0] === word);

      if (wordExistsInCSV) {
        console.log(`${chalk.red("‚ö†Ô∏è ", word, " already exists in csv")}`);
        await deletingFromCSV(word, sourceFilePath);
        return;
      }
    }
  } catch (error) {
    console.log(`${chalk.red("Unexpected error:", error.message)}\n`);
  }
}

================
File: src/utils/checkingAgainstDatabase.ts
================
import {readingLocalJSON} from "./readingLocalJSON";

export async function checkingAgainstDatabase(adjective: Adjective) {
  const localAdjectives: Adjectives = await readingLocalJSON();

  return localAdjectives.some(
    (localAdjective) =>
      localAdjective.singular_masculine === adjective.singular_masculine,
  );
}

================
File: src/utils/checkingJSONFiles.ts
================
import chalk from "chalk";

import {readingSourceFile} from "./readingJSONFile";

export async function checkingJSONFiles() {
  const filePaths: FilePath[] = ["./data/processed/wordsInSupabase.json"];

  console.log("üí° checking local database");

  try {
    for (const filePath of filePaths) {
      const wordsArray: Adjectives = await readingJSONFile(filePath);

      if (wordsArray.length > 0) {
        wordsArray.includes(adjective) ? true : false;
      } else {
        return true;
      }
    }
  } catch (error) {
    console.log(
      `${chalk.red("Unexpected error:", (error as Error).message)}\n`,
    );
  }
}

================
File: src/utils/creatingLocalBackup.ts
================
import fs from "fs/promises";
import chalk from "chalk";

export async function creatingLocalBackup(supabaseData: Adjectives) {
  console.log(`${chalk.white("üí° creating local backup")}`);

  const filePath: FilePath = "./data/wordsInSupabase.json";
  const backupFilePath: FilePath = "./data/backups/supabase";

  // creating backup
  const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
  await fs.copyFile(filePath, `${backupFilePath}.${timestamp}.backup`);

  try {
    await fs.writeFile(filePath, JSON.stringify(supabaseData, null, 2), "utf8");
  } catch (error) {
    console.log(
      `${chalk.red("Unexpected error:", (error as Error).message)}\n`,
    );
  }
  console.log(chalk.green("‚úÖ local backup saved successfully\n"));
}

================
File: src/utils/deletingFromCSV.ts
================
import fs from "fs/promises";
import Papa from "papaparse";
import chalk from "chalk";

export async function deletingFromCSV(word, targetFilePath) {
  console.log("üí° deleting from CSV");

  try {
    const sourceData = await fs.readFile(targetFilePath, "utf8");

    const parsedData = Papa.parse(sourceData, {
      header: true,
      skipEmptyLines: true,
      delimiter: "\n",
    });

    if (parsedData.errors.length > 0) {
      // Log the detailed error information
      console.log(chalk.red("CSV Parsing Errors:"));
      parsedData.errors.forEach((error, index) => {
        console.log(`${chalk.red(`Error ${index + 1}:`)} ${error.message}`);
        console.log(`${chalk.red("Row:")} ${error.row}`);
        console.log(`${chalk.red("Code:")} ${error.code}`);
        console.log(`${chalk.red("Type:")} ${error.type}`);
      });
      throw new Error(chalk.red("Error parsing the CSV file"));
    }

    const updatedData = parsedData.data.filter((row) => row.word !== word);

    if (updatedData.length === parsedData.data.length) {
      console.log(
        `${chalk.yellow("‚ö† word not found in CSV, no changes made")}\n`,
      );
      return;
    }

    const updatedCSV = Papa.unparse(updatedData);

    await fs.writeFile(targetFilePath, updatedCSV, "utf8");

    console.log(`${chalk.green("‚úÖ succesfully deleted from source csv")}`);
  } catch (error) {
    console.log(`${chalk.red("Unexpected error:", error.message)}\n`);
  }
}

================
File: src/utils/deletingFromJSONFiles.ts
================
import chalk from "chalk";

export async function deletingFromJSONFiles() {
  try {
  } catch (error) {
    console.log(
      `${chalk.red("Unexpected error:", (error as Error).message)}\n`,
    );
  }
}

================
File: src/utils/downloadingSupabaseData.ts
================
import fs from "fs/promises";
import chalk from "chalk";
import "dotenv/config";
import {createClient} from "@supabase/supabase-js";

const SUPABASE_URL = process.env.SUPABASE_URL!;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

export async function downloadingSupabaseData() {
  console.log(`${chalk.white("üí° reading supabase database")}`);

  const CONFIG = {
    DATABASE: {
      TABLE: "spanish_adjectives",
      FIELDS: [
        "singular_masculine",
        "singular_feminine",
        "plural_masculine",
        "plural_feminine",
        "ipa_singular_masculine",
        "ipa_singular_feminine",
        "ipa_plural_masculine",
        "ipa_plural_feminine",
        "syllabification_singular_masculine",
        "syllable_count_singular_masculine",
        "syllabification_singular_feminine",
        "syllable_count_singular_feminine",
        "syllabification_plural_masculine",
        "syllable_count_plural_masculine",
        "syllabification_plural_feminine",
        "syllable_count_plural_feminine",
        "links_to_audio_files_singular_masculine",
        "links_to_audio_files_singular_feminine",
        "links_to_audio_files_plural_masculine",
        "links_to_audio_files_plural_feminine",
        "english_translations",
        "french_translations",
        "italian_translations",
        "german_translations",
      ],
    },
  } as const;

  try {
    const {data, error} = await supabase
      .from(CONFIG.DATABASE.TABLE)
      .select(CONFIG.DATABASE.FIELDS.join(","));

    if (error) {
      console.error(
        chalk.red("‚ùå failed to fetch data from supabase:", error.message),
      );
      return [];
    }

    if (!data || data.length === 0) {
      console.log(chalk.red("‚ùå no data found in supabase, exiting..."));
      return [];
    }

    console.log(`${chalk.green("‚úÖ", data.length, "words found")}`);
    return data as Adjectives;
  } catch (error) {
    console.log(
      `${chalk.red("Unexpected error:", (error as Error).message)}\n`,
    );
  }
  return [];
}

================
File: src/utils/readingCSV.ts
================
import fs from "fs/promises";
import Papa from "papaparse";
import chalk from "chalk";

export async function readingCSV(sourceFilePath) {
  try {
    const sourceData = await fs.readFile(sourceFilePath, "utf8");

    const parsed = Papa.parse(sourceData, {
      header: true,
      skipEmptyLines: true,
    });

    if (!parsed.data || parsed.data.length === 0) {
      console.warn(
        `${chalk.red("‚ùå CSV file is empty or has no data rows")}\n`,
      );
      return null;
    }

    const words = parsed.data.map((row) => row.word).filter(Boolean);

    return words;
  } catch (error) {
    console.log(`${chalk.red("Unexpected error:", error.message)}\n`);
  }
}

================
File: src/utils/readingLocalJSON.ts
================
import fs from "fs/promises";
import chalk from "chalk";

export async function readingLocalJSON(): Promise<Adjectives> {
  console.log(`${chalk.white("üí° reading local database")}`);

  const filePath: FilePath = "./data/wordsInSupabase.json";

  const localAdjectives: Adjectives = [];

  try {
    const fileContent = await fs.readFile(filePath, "utf8");
    const words = JSON.parse(fileContent);

    if (!words || words.length === 0) {
      console.warn(
        `${chalk.red("‚ùå json file is empty or has no data rows")}\n`,
      );
      return [];
    }

    console.log(`${chalk.green("‚úÖ", words.length, "words found")}`);

    for (const word of words) {
      localAdjectives.push(word);
    }
  } catch (error) {
    console.log(
      `${chalk.red("Unexpected error:", (error as Error).message)}\n`,
    );
  }

  return localAdjectives;
}

================
File: src/utils/readingSourceFile.ts
================
import fs from "fs/promises";

import chalk from "chalk";

export async function readingSourceFile() {
  console.log(`${chalk.blue("üí° reading new words")}`);

  const filePath: FilePath = "./data/sources/adjectives.json";

  const wordsArray: Words = [];

  try {
    const fileContent = await fs.readFile(filePath, "utf8");
    const words = JSON.parse(fileContent);

    if (!words || words.length === 0) {
      console.warn(
        `${chalk.red("‚ùå json file is empty or has no data rows")}\n`,
      );
      return [];
    }

    console.log(
      `${chalk.green("‚úÖ", words.length, "words found in source file\n")}`,
    );

    for (const word of words) {
      wordsArray.push(word);
    }
  } catch (error) {
    console.log(
      `${chalk.red("Unexpected error:", (error as Error).message)}\n`,
    );
  }

  return wordsArray;
}

================
File: src/utils/syncLocalWithSupabase.ts
================
import chalk from "chalk";
import "dotenv/config";
import {createClient} from "@supabase/supabase-js";

import {readingLocalJSON} from "./readingLocalJSON";
import {downloadingSupabaseData} from "./downloadingSupabaseData";
import {creatingLocalBackup} from "./creatingLocalBackup";

const SUPABASE_URL = process.env.SUPABASE_URL!;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

export async function syncLocalWithSupabase() {
  console.log(`${chalk.blue("\nüí° syncing local data with supabase")}`);

  try {
    // loading local data
    const localData: Adjectives = await readingLocalJSON();

    // loading supabase data
    const supabaseData: Adjectives = await downloadingSupabaseData();

    // comparing local data with supabase data
    const isEqual = JSON.stringify(localData) === JSON.stringify(supabaseData);

    console.log(`${chalk.white("üí° comparing local data with supabase")}`);
    // if local data doesnt equal supabase data, supabase gets written to local json
    if (isEqual) {
      console.log(chalk.yellow("‚ö† local data is up-to-date with supabase\n"));
      return;
    } else {
      console.log(`${chalk.yellow("‚ö† differences found")}`);
      await creatingLocalBackup(supabaseData);
    }
  } catch (error) {
    console.log(
      `${chalk.red("Unexpected error:", (error as Error).message)}\n`,
    );
  }
}

================
File: src/utils/writingToCSV.ts
================
import fs from "fs/promises";
import Papa from "papaparse";
import chalk from "chalk";

export async function writingToCSV(word, targetFilePath) {
  console.log("üí° writing to CSV");

  try {
    const csvData = await fs.readFile(targetFilePath, "utf8");
    const parsedCSVData = Papa.parse(csvData, {
      header: false,
      skipEmptyLines: true,
    }).data;

    const wordExistsInCSV = parsedCSVData.some((row) => row[0] === word);

    if (wordExistsInCSV) {
      console.log(
        `${chalk.yellow("‚ö†Ô∏è ", word, " already exists in the CSV file, skipping write")}`,
      );
      return;
    }

    const wordObject = {word};
    const convertedWord = Papa.unparse([wordObject], {header: false});
    await fs.appendFile(targetFilePath, `\n${convertedWord}`);

    console.log(`${chalk.green("‚úÖ succesfully written to csv")}`);
  } catch (error) {
    console.log(`${chalk.red("Unexpected error:", error.message)}\n`);
  }
}

================
File: src/server.ts
================
import chalk from "chalk";

import {syncLocalWithSupabase} from "./utils/syncLocalWithSupabase";
import {readingSourceFile} from "./utils/readingSourceFile";
import {handlingAdjective} from "./controllers/adjectives/handlingAdjective";

async function main() {
  try {
    // sync the local json database with supabase
    // todo: create jsons for all word categories
    await syncLocalWithSupabase();

    // getting new words from the source json
    const words: Words = await readingSourceFile();

    // compare local supabase with the new words in source json
    // if there are new words remaining, pass them to to correspondending functions
    // like: adjectives to handling adjectives function
    await handlingAdjective(word);
  } catch (error) {
    console.log(
      `${chalk.red("Unexpected error:", (error as Error).message)}\n`,
    );
  }
}

main();

================
File: .dockerignore
================
node_modules
npm-debug.log
Dockerfile*
docker-compose*
.git
.gitignore

================
File: .prettierrc
================
{
    "semi": true,
    "singleQuote": false,
    "printWidth": 80,
    "tabWidth": 2,
    "trailingComma": "all",
    "bracketSpacing": false,
    "bracketSameLine": true,
    "arrowParens": "always",
    "parser": "typescript"
}

================
File: docker-compose.yml
================
services:
  # Development service
  dev:
    build:
      context: .
      target: development
    environment:
      - NODE_ENV=development
    volumes:
      - .:/app
    ports:
      - "3000:3000"
    command: ["npx", "tsx", "src/server.ts"]

  # Production service
  prod:
    build:
      context: .
      target: production
    environment:
      - NODE_ENV=production
    ports:
      - "3000:3000"
    command: ["node", "dist/server.js"]

================
File: Dockerfile
================
# stage 1: base image
FROM node:current-alpine3.20 AS base
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .

# stage 2: development
FROM base AS development
ENV NODE_ENV=development
CMD ["npx", "tsx", "src/server.ts"]

# stage 3: production
FROM base AS production
ENV NODE_ENV=production
RUN npm run build
CMD ["node", "dist/server.js"]

================
File: eslint.config.js
================
import eslint from "@eslint/js";
import jestPlugin from "eslint-plugin-jest";
import tseslint from "typescript-eslint";
import prettierConfig from "eslint-config-prettier";
import prettierPlugin from "eslint-plugin-prettier";

export default tseslint.config(
  {
    ignores: ["**/build/**", "**/dist/**"],
  },
  eslint.configs.recommended,
  tseslint.configs.recommended,
  prettierConfig,
  {
    plugins: {
      "@typescript-eslint": tseslint.plugin,
      jest: jestPlugin,
      prettier: prettierPlugin,
    },
    languageOptions: {
      parser: tseslint.parser,
      parserOptions: {
        projectService: true,
      },
    },
    rules: {
      "prettier/prettier": "error",
      "@typescript-eslint/no-unsafe-argument": "error",
      "@typescript-eslint/no-unsafe-assignment": "error",
      "@typescript-eslint/no-unsafe-call": "error",
      "@typescript-eslint/no-unsafe-member-access": "error",
      "@typescript-eslint/no-unsafe-return": "error",
    },
  },
  {
    // disable type-aware linting on JS files
    files: ["**/*.js"],
    extends: [tseslint.configs.disableTypeChecked],
  },
  {
    // enable jest rules on test files
    files: ["test/**"],
    extends: [jestPlugin.configs["flat/recommended"]],
  },
);

================
File: package.json
================
{
  "name": "lila-language-data",
  "version": "1.0.0",
  "description": "script to gather language data",
  "license": "GPL-3.0-or-later",
  "author": "languagedev",
  "type": "module",
  "main": "server.ts",
  "repository": "github:language-dev243/lila-language-data",
  "scripts": {
    "format": "prettier --write .",
    "lint": "eslint .",
    "build": "tsc",
    "start": "node dist/server.js",
    "dev": "tsx src/server.ts",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "devDependencies": {
    "@eslint/js": "^9.18.0",
    "@supabase/supabase-js": "^2.47.13",
    "@types/eslint-config-prettier": "^6.11.3",
    "@types/node": "^22.10.6",
    "@types/papaparse": "^5.3.15",
    "axios": "^1.7.9",
    "cheerio": "^1.0.0",
    "dotenv": "^16.4.7",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-import": "^2.31.0",
    "eslint-plugin-jest": "^28.11.0",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-prettier": "^5.2.3",
    "globals": "^15.14.0",
    "husky": "^9.1.7",
    "lint-staged": "^15.4.1",
    "papaparse": "^5.5.1",
    "prettier": "^3.4.2",
    "tsx": "^4.19.2",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "dependencies": {
    "chalk": "^5.4.1"
  }
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "strict": true,
    "strictNullChecks": true,
    "declaration": true,
    "allowSyntheticDefaultImports": true,
    "resolveJsonModule": true,
    "sourceMap": true,
    "moduleResolution": "node",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "typeRoots": [
      "./node_modules/@types",
      "./types/global.d.ts"
    ],
    "baseUrl": "./",
    "paths": {
      "@utils/*": [
        "src/utils/*"
      ],
      "@controllers/*": [
        "src/controllers/*"
      ],
      "@services/*": [
        "src/services/*"
      ]
    },
  },
  "include": [
    "./src/*",
    "./src/types/*",
    "./types/global.d.ts",
    "src/utils/syncLocalWithSupabase.ts",
    "src/adjectives/handlingAdjective.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
